/**
 * JavaCC file
 */

options {
  JDK_VERSION = "1.8";
  STATIC = false;
}
PARSER_BEGIN(PidginParser)
package parser;

import ast.*;
import java.util.ArrayList;
import java.util.List;
import parser.parsetree.*;
import util.*;
import java.util.Collections;

public class PidginParser {
}

PARSER_END(PidginParser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
|	< MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" >
|   < SINGLE_LINE_COMMENT: "//" (~["\n"])* >
}

/* string */
TOKEN:
{
  <QUOTE:"\""> : STRING_STATE
}

<STRING_STATE> MORE:
{
  "\\" : ESC_STATE
}

<STRING_STATE> TOKEN:
{
  <ENDQUOTE:<QUOTE>> : DEFAULT
| <CHAR:~["\"","\\"]>
}

<ESC_STATE> TOKEN:
{
  <CNTRL_ESC:["\"","\\","/","b","f","n","r","t"]> : STRING_STATE
}
/* string ends */

TOKEN : /* KEYWORDS */
{
	<LET:		 "let" >
|   <IN:         "in" >
|   <GRAPH:         "pdg" >
|   <FORWARDS:   "forwardSlice" >
|   <BACKWARDS:  "backwardSlice" >
|   <REMOVEN:    "removeNodes" >
|   <REMOVEE:    "removeEdges" >
|   <FOREXP:     "forExpression" >
|   <FORPROC:    "forProcedure" >
|   <ISEMPTY:    "is empty">
|   <DEFAULT_T:  "default">
|   <UNION:  "union">
|   <INTERSECT:  "intersect">
|   <OR:  "or">
}
TOKEN : /* SElPARATORS and OPERATORS*/
{	<LPAREN: "(">
|	<RPAREN: ")">
|	<ASSIGN: "=">
|	<QUESTION:	 "?">
|	<COLON:	 ":" >
|	<PLUS:	 "+" >
|	<MINUS:  "-" >
|	<MULT:   "*" >
|	<SMALLER:"<">
|	<NOT:	 "!">
| 	<SEMICOLON:	 ";" >
| 	<DOT:	 "." >
}

// Must declare aboe "identifier" which matches first
TOKEN : /* TYPES */
{ <INT: "int">
| <BOOLEAN: "boolean">
}

TOKEN :
{   < INTEGER_LITERAL: ( <DIGIT> )+ >
|   < IDENTIFIER: <LETTER> (<LETTER> | "_" | <DIGIT>)* >
|   < #LETTER: ["A" - "Z", "a" - "z"] >
|   < #DIGIT: ["0" - "9"] >
}





Program Program() : {
    List<Expression> expressions = new ArrayList();
	Expression e;
	Policy p;
}
{
	( LOOKAHEAD(2) e=Expression()
		{ expressions.add(e); }
	)*
	p = Policy()
	<EOF>
	{ return new Program(expressions, p); }
}

Policy Policy() : {
// TODO what is this p(A_0, ... A_n) variant?
    Expression e, e2;
    List<Expression> es = new ArrayList();
}{
     e=Expression() {es.add(e);} (<IN> e2=Expression() { es.add(e2);} )* <ISEMPTY> { return new IsEmpty(es); }
}

Procedure Procedure() : {
    String i;
    Expression e;
    Boolean isEmpty = false;
    }{
    <LET> i=Identifier() <ASSIGN> e=Expression()
    ( LOOKAHEAD(2) <ISEMPTY> { isEmpty = true; })?
    { //if (isEmpty) {
    //    return new IsEmpty(Collections.singletonList(new Procedure(i, e))); } // TODO weird edge case with is empty syntax
    //else  {
        return new Procedure(i, e);
    }
} // TOOD unsure how this works

//Type Type() : {
//    Token t;
//} {
//    t= <BOOLEAN> { return new BooleanType(); }
//    | <INT> { return new IntegerType(); }
//}

Argument Argument() : {
    EdgeType et;
    NodeType nt;
    String i;
} {
     LOOKAHEAD(2)
      et=EdgeType() { return et; }
     | nt=NodeType() { return nt; }
     | i=Identifier() { return new Var(i); }// TODO JavaExpression
}

//Argument JavaExpression() : {
//    String i;
// }{
//// TODO how to handle? parse like a regular string I guess
//    i = Identifier() { is.add(i); } (i = Identifier() { is.add(i); }) *
//    { return is; }
//}


// TODO there is no Boolean condition!!
PrimitiveExpression PrimitiveExpression() : {
    Argument e;
    String i;
}{
// TODO Argument or Expression?
    <FORWARDS> <LPAREN> e=Argument() <RPAREN> { return new Forwards(e); }
     | <BACKWARDS> <LPAREN> e=Argument() <RPAREN> { return new Backwards(e); }
     | <REMOVEN> <LPAREN> e=Argument() <RPAREN> { return new Remove(true, e); }
     | <REMOVEE> <LPAREN> e=Argument() <RPAREN> { return new Remove(false, e); }
     | <FOREXP> <LPAREN> i=string() <RPAREN> { return new ForExpression(i); }
     | <FORPROC> <LPAREN> i=Identifier() <RPAREN> { return new ForProcedure(new Var(i)); }
}


EdgeType EdgeType() : {} {
// todo use edgetype.from if possible
    <DEFAULT_T> { return EdgeType.DEFAULT; }
}

NodeType NodeType() : {} {
    <DEFAULT_T> { return NodeType.DEFAULT; }
}

Expression Expression() : {
    Procedure f;
	Expression e, e2, e3;
	List<Expression> eList = new ArrayList();
	List<Expression> eList2 = new ArrayList();
	String i;
}
{   <GRAPH> (<DOT> (e2=PrimitiveExpression() { eList.add(e2); })+ )? { // todo OR? forProcedure needs to be collected under a label
if (!eList.isEmpty()) { return new parser.parsetree.Graph(); } else { return new Graph(); }}
	| LOOKAHEAD(2)
	<LET> i=Identifier() <ASSIGN> e=Expression() {eList.add(e); eList2.add(e);}
	( LOOKAHEAD(2) <OR> e2=Expression() {eList.add(e2); } )*
	(LOOKAHEAD(2) <IN> e3=Expression() {eList2.add(e3);})* { return new Assign(new Var(i), eList2, eList); }
	| i=Identifier() { return new Var(i); }
	| f=Procedure() { return f; }

}

// creates left recursion
// what examples exist?
Expression SetOperation() : {
    Expression e1, e2;
} {
    LOOKAHEAD(2) e1=Expression() <UNION> e2=Expression() { return new Union(e1, e2); }
    | e1=Expression() <INTERSECT> e2=Expression() { return new Intersect(e1, e2); }
}

String Identifier() : {
	Token i;
}
{
	i = <IDENTIFIER>
	{ return i.image; }
}


// https://stackoverflow.com/questions/11878392/parsing-strings-with-javacc
String string() :
{
  StringBuilder builder = new StringBuilder();
}
{
  <QUOTE> ( getChar(builder) )* <ENDQUOTE>
  {
    return builder.toString();
  }
}

/**
 * Match char inside quoted string.
 */
void getChar(StringBuilder builder):
{
  Token t;
}
{
  ( t = <CHAR> | t = <CNTRL_ESC> )
  {
    if (t.image.length() < 2)
    {
      // CHAR
      builder.append(t.image.charAt(0));
    }
    else if (t.image.length() < 6)
    {
      // ESC
      char c = t.image.charAt(1);
      switch (c)
      {
        case 'b': builder.append((char) 8); break;
        case 'f': builder.append((char) 12); break;
        case 'n': builder.append((char) 10); break;
        case 'r': builder.append((char) 13); break;
        case 't': builder.append((char) 9); break;
        default: builder.append(c);
      }
    }
  }
}