package test.unit;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;

import junit.framework.TestCase;

import org.json.JSONException;
import org.json.JSONObject;

import accrue.pdg.ProgramDependenceGraph;
import accrue.pdg.graph.PDGFactory;
import accrue.pdg.node.AbstractPDGNode;
import accrue.pdg.node.PDGNodeClassName;
import accrue.pdg.node.PDGNodeFactory;
import accrue.pdg.node.PDGNodeType;

/**
 * Useful methods for test writing
 */
public class Helper extends TestCase {
    /**
     * Load a dot file into a {@link String}
     * 
     * @param filename
     *            name of file where the dot lives
     * 
     * @return dot formatted string
     */
    public static String loadDot(String filename) {
        FileInputStream fstream = null;

        try {
            fstream = new FileInputStream(filename);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        }

        DataInputStream in = new DataInputStream(fstream);
        BufferedReader br = new BufferedReader(new InputStreamReader(in));

        String dotInput = "";
        try {
            while (br.ready()) {
                dotInput += (br.readLine() + "\n");
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return dotInput;
    }

    /**
     * Load a .json file generated by infoflow and check that it is read in
     * correctly by comparing the .dot files from this and infoflow
     * 
     * @param prefix
     *            filename for the .json and .dot files being tested. These
     *            should be located in ./tests/
     * 
     * @return a new program dependence graph for the given file
     */
    public static ProgramDependenceGraph testAndLoad(String prefix) {
        ProgramDependenceGraph pdg = PDGFactory.graphFromJSONFile("tests/" + prefix + ".json", false);

        // Get rid of the indices which are of the form (num), since these are
        // just for defining unique nodes. This could introduce some
        // imprecision.
        String output = PDGFactory.uniquifiedDot(pdg, true, 0.5, null, null).replaceAll(" \\([0-9]*\\)", "");
        String input = Helper.loadDot("tests/" + prefix + ".dot").replaceAll(" \\([0-9]*\\)", "");
        // The dot is the same for infoflow and this tool
        String[] ss = output.split("\n");
        for (int i = 0; i < ss.length; i++) {
            assertTrue("input does not contain " + ss[i], input.contains(ss[i]));
        }
        String[] ss2 = input.split("\n");
        for (int i = 0; i < ss2.length; i++) {
            assertTrue("output does not contain" + ss2[i], output.contains(ss2[i]));
        }

        return pdg;
    }
    
    
    /**
     * Unique ID counter
     */
    private static int counter = 0;
    
    /**
     * Create a new dummy "PC merge" node
     * 
     * @param name
     *            descriptive name for display
     * @return new node
     */
    public static AbstractPDGNode createPCMerge(String name) {
        
        AbstractPDGNode n;
        try {
            n = PDGNodeFactory.create(new JSONObject().put("class", PDGNodeClassName.EXPR.toString())
                    .put("position", JSONObject.NULL)
                    .put("nodeid", ++counter)
                    .put("name", name)
                    .put("type", PDGNodeType.PC_MERGE.toString())
                    .put("merge", true)
                    .put("group", "group")
                    .put("code", "code")
                    );
            return n;
        } catch (JSONException e) {
            throw new RuntimeException(e.getMessage());
        }     
    }
    
    /**
     * Create a new dummy node that is not a PC node
     * 
     * @param name
     *            descriptive name for display
     * @return new node
     */
    public static AbstractPDGNode createNonPCMerge(String name) {
        
        AbstractPDGNode n;
        try {
            n = PDGNodeFactory.create(new JSONObject().put("class", PDGNodeClassName.ABSTRACT_LOCATION.toString())
                    .put("position", JSONObject.NULL)
                    .put("nodeid", ++counter)
                    .put("name", name)
                    .put("type", PDGNodeType.ABSTRACT_LOCATION.toString())
                    .put("merge", true)
                    .put("group", "group")
                    .put("location", "location")
                    );
            return n;
        } catch (JSONException e) {
            throw new RuntimeException(e.getMessage());
        }     
    }
}
